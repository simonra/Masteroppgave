\chapter{Theory}

In the pre-project leading up to this work we performed a structured literature review (TODO: SOURCE). Our focus was finding whether snow plowing was a known and solved problem, and in case it was, how should one go about trying to solve it. In the following sections we will outline what we found about the classification of the problem, and known approaches.

\section{The Node, Edge, and Arc Rouring Problem(s)}
\label{the_nearp}
In our structured literature review we found that the current take on problems like snow plowing has long roots. The simplest possible interpretation is that it is about traversing a graph G=\{N,E\} in a certain way. Which would make it similar to the “Seven bridges of Königsberg Problem”, that is about finding a cycle that traverses the graph and visits all the edges exactly once, and was solved by the Swiss mathematician Leonhard Euler in 1735.

But it was not untill more than 200 years later (in 1962) that a graph traversal problem that is more relevant to snow plowing was proposed. The chinese mathematician, and former postman, Mei-Ko Kwan described the problem of finding the shortest trip that visits all the edges in a graph at least once. It is the converse of the Vehicle Routing Problem (VRP), which is about visiting all the nodes of the graph at the lowest possible cost. The problem became known as the Chinese Postman Problem.

The CPP, if it contains only undirected edges or directed edges (arcs) (G=\{N,E\} or G=\{N,A\}), can be solved in polynomial time. But if it is a mixed graph containing both (G=\{N,E,A\}) it is NP-hard.

Over the following decades several variations on the probem were made to handle speciffic challenges. We will now briefly define the most known formulations and how they are tied to snow plowing.

The Rural Postman Problem (RPP) arose when one wanted to optimize solutions for when the postman does not have to visit all the edges, but only a subset of them. Which is a situation that is likely to arise in snow plowing, where one for an instance has to service all the roads in a city with a certain amount of trafic, but can pass through the less used roads to move between the ones that have to be plowed.

The Mixed Chinese Postman Problem (MCPP) is the apporach to the CPP where one looks at the problem in a mixed graph (with both arcs and edges). It introduces a relevant constraint when considering practical applications, such as snow plowing, where the underlying graph represents a road network. Not only is it a very natural representation of a road network containing both bi-directional and one way roads, it can also be used to handle cases such as intersections with forbidden turns. 

The Hierarchical Chinese Postman Problem (HCPP) came about when one wanted to investigate how solutions would change if one required some edges to be serviced before others. It is a situation that often arises in practice. For an instance in snow plowing one might want to service a more used road before a less used road.

The Windy Postman Problem (WPP) is the attempt at accounting for that an edge can have a different cost each time you pass through it. This is a relevant consideration when snow plowing, because simply passing through a road and plowing it takes a different amount of resources and time, and even passing through a road that has already been plowed and one that has not can have separate costs.

The k-postman Chinese Postman Problem (k-CPP) is the attempt at modeling a scenario where there is a depot node, and k postmen, or one postman that can do k trips of a certain cost. Taking it a step further, the Min-Max k-CPP (MM k-CPP) looks at minimizing the the trip with the maximal cost of the k trips. This is relevant for the snow plowing case where there is a large road network and there is no single vehicle that is capable of service all of it in one go. If implemented correctly it can even be argued that the splitted trips from the k-CPP can be used for sectoring the road network between different contractors.

Now where all these variations on the CPP focus on general graphs, although they arguably can be applied to a broad spectrum of tasks in real world road networks, the Arc Routing Problem (ARP) has also been defined. It is used to describe problems centered around servicing arcs in transport networks. The main difference from the various CPPs tends to be the more vehicle oriented terminology that is used, which makes it somewhat difficult to describe how they relate to one another. It can both be argued that the ARP is a more general version of the CPP with a somewhat different terminology, and that it is a special applied case of the CPP.

What makes it interesting for snow plowing is that in later years the literature dealing with applied routing with the goal of visiting/servicing the arcs and/or edges in a graph has been favoring the ARPs terminology over that of the CPP.

Specially the variation known as the Capacitated Arc Routing Problem (CARP) has been widely studied. It has much in common with the k-CPP, because it deals with the case of having a set of identical vehicles with a limited capacity located at a depot. The task of which is to service the roads in a network in such a way that each road gets serviced by one vehicle once. However, like the k-CPP it suffers from that it is to general to give a good description of complex problems like snow plowing.

This has in turn given rise to definitions that try to include more constraints so that the problems one wants to solve are moer accurately described. Within the ARP paradigm the Extended Capacitated Arc Routing Problem (ECARP) has been defined to handle this. It tries to take into account things such as that there the problem might be in a mixed graph, the edges/arcs can have a varying cost, special constraints such as u-turns being forbidden in ordinary intersections, a maximum limit on trip lengts, and so on.

The problem definition we found that fits our case best however is the Node Edge and Arc Routing Problem (NEARP). It describes the problem of servicing a subset of the nodes, edges, and arcs in a mixed graph, with a homogeneous set of vehicles. Like in the k-CPP and CARP each vehicle is capacitated in terms of demand it can service (cost it can handle). The elements of the graph that require servicing have a fixed demand, and the all the arcs and edges have a traversal cost while nodes have no traversal cost. 

Because it combines the CARP, VRP, and the General Routing Problem, it takes into account all the features of the underlying network we want to use when structuring our graph, such as the assumption of a mixed graph. Another feature that makes it a better model is that it considers both nodes, arcs, and edges as elements of the graph that can need servicing. This makes very much sense in a snow plowing setting where not only roads and one way driven roads, but also intersections need to be plowed.

Now that we have defined what kind of problem we want to solve, we need to look into how it can be solved.


% section the_nearp (end)

% Historical approaches and solutions -> What we gonna use ((M)EA) -> EA -> Fitness -> FLW (basiskomponent) -> Grand tour vs Split som fitness -> Split forklart.

\section{Routing Algorithms} % (fold)
\label{sec:routing_algorithms}

In our structured literature review we came across several methods of solving routing problems. Clearly, the most desirable outcome would be a solution that can be known to be optimal. And for the polynomial time cases such as the plain CPP where all the edges have to be serviced by one postman exact solutions methods have been made. But for the NP-hard cases like the CARP exact solutions quickly become infeasible as problem sizes grow. Some of the best apporaches perform well for problems with up to 7 vehicles, 50 nodes, and 97 edges.

This has lead to efforts in persuing other ways of finding solutions. Some have tried probablistic approaches, but the majority of work has been done on heurisitc methods. Simulated Annealing and Tabu search have been used successfully to give good results. It has been shown that A* can give approximate solutions, but this approach suffers from that there is a signifficant tradeoff between the quality of the solutions it finds, and its capability of processing larger problems withing reasonable time.

Other methods that have shown to be robust both in terms of quality of solutions are Ant Colony Optimization (ACO) and Greedy Radnomized Adaptive Search Procedure (GRASP). Both yield solutions of a similar quality as those found by Tabu Search, but ACO outpreforms GRASP on running time.

Lately the most promising results have been given by Evolutionary Algorithms (EA). Genetic Algorithms (GA) have been shown to give high quality solutions for large instances of the CARP/NEARP, and and generally outpreform other non-evolutionary methods. A further improvement on GAs has been made by Memetic Algorithms (MA). They have a reasonable running time, and they are capable of finding the highest quality solutions for the larger problem instances.

As such MAs can be considered as the current state of the art apporach to solving the NEARP, which is the reason we chose to base our work with snow plowing in Trondheim on them.

% section routing_algorithms (end)


\section{Evolutionary Algorithms} % (fold)
\label{sec:evolutionary_algorithms}
Now that the reasons for using an EA has been laid out, one should consider what EAs are, and how they can be implemented. EAs were one of the earliest bio-inspired algorithms, introduced by Alan Turing. The idea is that EAs should mimic the biological processes in evolution, abstracting potential solutions to a population of individuals that have traits which are combined and altered through generations.

A common way to make an EA is to implement a GA. In the paradigm of the GA, at the core of each individual there is a genome. This genome is an alternative representation of a solution to the probem one is trying to solve with the GA that satisfies certain properties.

When there is a new generation, new individuals are made by combining existing memebers of the population. This is done by taking two or more individuals, and combining their genomes into a new genome, that becomes the foundation for a new individual. A genome must thus be constructed in such a way that it can be merged with another genome in such a way that the output is a valid genome that represents a solution.

Each new genome when created has a cance of undergoing mutation. In practice this often means that one of its components gets an altered value, or two components swap places in the genome, yielding a new altered genome. This ensures that there is always some random variation in the population, making it less prone to becoming stuck in a local optimum.

It must also be possible to convert a genome to a solution of the problem the GA is trying to solve. The solution obtained from a genome is called an inidviduals phenotype. These phenotypes should take a reasonable time to generate, specially because they are often the foundation for calculating an individuals fitness.

The fitness can then be used to determine whether an optimal solution to the problem has been found. If not, for an instance because it is unknown what a problems global optimal value is, the fitness is often used in determining what individuals are coupled when the nex generation is created, and what combination of pre-existing individuals and new inidviduals should make up the population at the end of the generation/beginning of the next generation.

To improve on GAs the concept of memeticism can be introduced, turning them into MAs. Memeticism is the term used for describing that individuals can be improved after being generated, mimicing the ability of real life organism in evolutionary systems to learn. In practice this is often done by replacing the mutation step with doing a simple local search to improve the genome.

\subsection{Fitness for Snow Plowing} % (fold)
\label{sub:fitness_for_snow_plowing}

% subsection fitness_for_snow_plowing (end)

\subsection{The Split Algorithm} % (fold)
\label{sub:the_split_algorithm}

% subsection the_split_algorithm (end)

\subsection{All Pairs Shortest Path} % (fold)
\label{sub:all_pairs_shortest_path}

% subsection all_pairs_shortest_path (end)


% section evolutionary_algorithms (end)



% \subsection{Evolutionary Algorithms}
% Why we chose this approach
% 	(Many approaches to the problem have been tried, examples, however in our previous work we found that MA's were good)
% \\\\
% Description of:
% Turing -> modern interpretations
% \\\\
% Memeticism

\cleardoublepage