\appendix
\section*{\begin{center}{\Huge Appendix}\end{center}}
\addcontentsline{toc}{chapter}{Appendix}
% $\\[0.5cm]$


\chapter{Implementation Details} % (fold)
\label{cha:implementation_details}

\section{All Pairs Shortest Path} % (fold)
\label{sec:all_pairs_shortest_path}

When we a route parts of our fitness evaluation rely on the distance between elements in the graph. To make the process of aquiring the distances fast and legible in the code we chose to use an all pairs shortes path matrix (SOURCE), and to construct it we relied on the Floyd-Warshall algorithm (SOURCE). In a lot of the literature Dijkstras algorithm (SOURCE) is used iteratively for this purpose (SOURCES). However, because it has the same asympthotical running time (SOURCE) and it has a much more compact syntax, we chose to work with the Floyd-Warshall algorithm.
\\\\
Due to that our graph represents a NEARP, and we therefore wanted the all pairs shortest path matrix to hold the shortest path betwee all the elements in the graph (not just nodes, but nodes, arcs, and edges), we ran into some challenges. Usually one would look at the distance between nodes, and the way Floyd-Warshall constructs the matrix, nodes with no distance are effectively treated as the same node. When we interpret going onto an arc as having no cost, and going of an arc to the node it is connected to as not having any cost, the algorithm interprets going from the first to the second node as having no cost, and them effectively being the same node for calculating further costs/distances.
\\\\
Essentially we ended up in a situation where there would be no cost going to a neighbor, but passing through it to the next neighbor would have a cost.



\begin{algorithm}
\caption{Floyd-Warshall}\label{floyd-warshall-pseudocode}
\begin{algorithmic}[1]

\Procedure{Floyd-Warshall}{Graph}
	\State \textbf{let} $numberOfElements \leftarrow \sum (|N|+|E|+|A|) \in Graph$
	\State \textbf{let} $distances$ be a $numberOfElements \times numberOfElements$ array
	\State \textbf{let} $successors$ be a $numberOfElements \times numberOfElements$ array
	\State \textbf{set} all entries in $distances$ \textbf{to} $\infty$
	\State \textbf{set} all entries in $successors$ \textbf{to} $-1$
	\Statex
	\For{\textbf{each} element $e \in N \cup E \cup A \in Graph$}
		\State $distances[e][e] \leftarrow 0$
		\State $successors[e][e] \leftarrow e$
	\EndFor
	\Statex
	\For{\textbf{each} element $e \in N \cup E \cup A \in Graph$}
		\State \textbf{let} $adjacent \leftarrow $ elements adjacent to $e$ in $Graph$
		\For{\textbf{each} element $e_a \in adjacent$}
			\State $distances[e][e_a] \leftarrow e_a.passThroughCost$
			\State $successors[e][e_a] \leftarrow e_a$
			\State $successors[e_a][e] \leftarrow e$
		\EndFor
	\EndFor
	\Statex
	\For{$k \leftarrow 0$ \textbf{to} $numberOfElements$}
		\For{$i \leftarrow 0$ \textbf{to} $numberOfElements$}
			\For{$j \leftarrow 0$ \textbf{to} $numberOfElements$}
				\If{$distances[i][j] > distances[i][k] + distances[k][j]$}
					\State $distances[i][j] = distances[i][k] + distances[k][j]$
					\State $successors[i][j] = successors[i][k]$
				\EndIf
			\EndFor
		\EndFor
	\EndFor
	\Statex
	\For{\textbf{each} element $(e_i,e_j) \in N \cup E \cup A \in Graph$}
		\If{$e_i \neq e_j$}
			\State $distances[e_j][e_i] \leftarrow distances[e_j][e_i] - e_i.passThroughCost$
		\EndIf
	\EndFor
\EndProcedure

\end{algorithmic}
\end{algorithm}

% section all_pairs_shortest_path (end)

\section{Split Heuristic} % (fold)
\label{sec:split_heuristic}

The pseudocode for the split algorithm:

\begin{algorithm}
\caption{Split}\label{split-pseudocode}
\begin{algorithmic}[1]

\Procedure{Split}{Genotype,Graph,Distances}
	\State \textbf{let} $numberOfElements \leftarrow \sum (|N|+|E|+|A|) \in Graph$
	\State \textbf{let} $e_k$ be the k'th element from the Genotypes ordering of the set $(N \cup E \cup A) \in Graph$ in its genome
	\State \textbf{let} $costs$ be an array of length $numberOfElements + 1$
	\State \textbf{let} $predecessors$ be an array of length $numberOfElements + 1$
	\State \textbf{set} all entries in $predecessors$ to $\infty$
	\State $costs[0] \leftarrow 0$
	\State $predecessors[0] \leftarrow 0$
	\Statex
	\For{$i \leftarrow 1$ \textbf{to} $numberOfElements + 1$}
		\State $j \leftarrow i$
		\State $load \leftarrow 0$
		\State $cost \leftarrow 0$
		\DoWhile
			\State $load \leftarrow load + e_j.demand$
			\Statex
			\If{$i = j$}
				\State $cost \leftarrow($ distance from depot to $e_{i-1}) + e_{i-1}.servicing\_cost +($ distance from $e_{i-1}$ to the depot $)$
			\Else
				\State $cost \leftarrow($ distance from depot to $e_{j-2}) + ($distance from $e_{j-2}$ to $e_{j-1}) + e_{j-1}.servicing\_cost +($ distance from $e_{j-1}$ to the depot $)$
			\EndIf
			\Statex
			\If{$(load < vehicle\_capacity)\wedge(costs[i - 1] + cost < costs[j])$}
				\State $costs[j] \leftarrow costs[i - 1] + cost$
				\State $predecessors[j] \leftarrow i - 1$
			\EndIf
			\Statex
			\State $j \leftarrow j + 1$
		\EndDoWhile{$(j < numberOfElements + 1)\wedge(load < vehicle\_capacity)$}
	\EndFor
	\Statex
	\State \textbf{let} $Genotype.fitness \leftarrow costs[last\_index]$
\EndProcedure

\end{algorithmic}
\end{algorithm}

The pseudocode for retrieving trips for individual vehicles from the output of the split algorithm:

\begin{algorithm}
\caption{Retrieve Trips from Split}\label{split-retrieve-pseudocode}
\begin{algorithmic}[1]

\Procedure{Retrieve Trips From Split}{costs, predecessors, genotype}
	\State \textbf{let} $list\_of\_trips$ be an empty list
	\State $j \leftarrow$ number of tasks
	\DoWhile
		\State $i \leftarrow predecessors[j]$
		\State \textbf{let} $current\_trip$ be a new array of size $j - i$
		\For{$k \leftarrow i + 1$ \textbf{to} $k \leq j$, $k \leftarrow k + 1$}
			\State $current\_trip[k-(i+1)] \leftarrow genotype.genome[k-1]$
		\EndFor
		\State \textbf{add} $current\_trip$ \textbf{to} the beginning of $list\_of\_trips$
	\EndDoWhile{$i \neq 0$}
\EndProcedure

\end{algorithmic}
\end{algorithm}

% section split_heuristic (end)

\section{Calcualtion of the cost of a single vehicle trip} % (fold)
\label{sec:calcualtion_of_the_cost_of_a_single_vehicle_trip}

\begin{algorithm}
\caption{Trip Cost}\label{trip-cost-pseudocode}
\begin{algorithmic}[1]

\Procedure{Trip Cost}{trip}
	\State $cost \leftarrow$ distance from depot to $trip[0] + trip[0].servicing\_cost$
	\State $sum \leftarrow trip[0].demand$
	\For{$i \leftarrow 1$ to number of elements in $trip$}
		\State $cost$
		\State $sum$
	\EndFor
	\State $cost \leftarrow$ distance from last task in $trip$ to depot
	\State $demand\_slope \leftarrow \frac{sum - average\_number\_of\_tasks \times average\_demand}{variance\_of\_tasks}$
	\If{$deamnd\_slope > 0$}
		\State Increase cost to penalize trend of doing higher priority tasks late
r	\EndIf
\EndProcedure

\end{algorithmic}
\end{algorithm}


% section calcualtion_of_the_cost_of_a_single_vehicle_trip (end)

\section{Evolutionary Algorithm} % (fold)
\label{sec:evolutionary_algorithm}

\subsection{Genome} % (fold)
\label{sub:genome}
% subsection genome (end)

% section evolutionary_algorithm (end)

% chapter implementation_details (end)


